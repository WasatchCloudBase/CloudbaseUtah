import SwiftUI
import MapKit
import Combine
import UIKit
import CoreGraphics
import CoreLocation
import Foundation

struct OldMapView: View {
    @EnvironmentObject var liftParametersViewModel: LiftParametersViewModel
    @EnvironmentObject var sunriseSunsetViewModel: SunriseSunsetViewModel
    @EnvironmentObject var weatherCodesViewModel: WeatherCodesViewModel
    @EnvironmentObject var sitesViewModel: SitesViewModel
    @EnvironmentObject var pilotsViewModel: PilotsViewModel
    @EnvironmentObject var mapSettingsViewModel: MapSettingsViewModel
    @Environment(\.scenePhase) private var scenePhase
    @StateObject private var stationLatestReadingsViewModel: StationLatestReadingsViewModel
    @StateObject private var pilotTracksViewModel: PilotTracksViewModel
    @StateObject private var annotationSourceItemsViewModel: AnnotationSourceItemsViewModel
    @State private var selectedSite: Sites?
    @State private var selectedPilotTrack: PilotTracks?
    @State private var isLayerSheetPresented = false
    @State private var isPlaying = false
    @State private var animationProgress: Double = 0.0
    @State private var currentTime: String = "00:00"
    @State private var annotationSourceItems: [AnnotationSourceItem] = []
    @State private var isActive = false                         // Whether view is active for time refreshes
    @State private var refreshWorkItem: DispatchWorkItem?       // Used to cancel and restart timer when another event occurs
    @State private var region = MKCoordinateRegion(
        center: CLLocationCoordinate2D(latitude: mapInitLatitude, longitude: mapInitLongitude),
        span: MKCoordinateSpan(latitudeDelta: mapInitLatitudeSpan, longitudeDelta: mapInitLongitudeSpan))
    @State private var position = MapCameraPosition.region(MKCoordinateRegion(
        center: CLLocationCoordinate2D(latitude: mapInitLatitude, longitude: mapInitLongitude),
        span: MKCoordinateSpan(latitudeDelta: mapInitLatitudeSpan, longitudeDelta: mapInitLongitudeSpan)))
    @State private var lastRegionSpan: MKCoordinateSpan = MKCoordinateSpan(latitudeDelta: 0, longitudeDelta: 0)
    private var cancellables = Set<AnyCancellable>()
    
    init(sitesViewModel: SitesViewModel) {
        _stationLatestReadingsViewModel = StateObject(wrappedValue: StationLatestReadingsViewModel(viewModel: sitesViewModel));
        _pilotTracksViewModel = StateObject(wrappedValue: PilotTracksViewModel())
        _annotationSourceItemsViewModel = StateObject(wrappedValue: AnnotationSourceItemsViewModel(
            mapSettingsViewModel: MapSettingsViewModel(
                region: MKCoordinateRegion(
                    center: CLLocationCoordinate2D(latitude: mapInitLatitude, longitude: mapInitLongitude),
                    span: MKCoordinateSpan(latitudeDelta: mapInitLatitudeSpan, longitudeDelta: mapInitLongitudeSpan)
                ),
                activeLayers: defaultActiveLayers,
                selectedMapType: .standard,
                pilotTrackDays: defaultPilotTrackDays),
            sitesViewModel: SitesViewModel(),
            stationLatestReadingsViewModel: StationLatestReadingsViewModel(viewModel: SitesViewModel())))
    }
    
    var body: some View {
        ZStack {
            
            // Validate annotation coordinates
            let _ = annotationSourceItemsViewModel.clusteredAnnotationSourceItems.forEach { annotation in
                assert(annotation.coordinates.latitude >= -90 && annotation.coordinates.latitude <= 90, "Invalid latitude: \(annotation.coordinates.latitude)")
                assert(annotation.coordinates.longitude >= -180 && annotation.coordinates.longitude <= 180, "Invalid longitude: \(annotation.coordinates.longitude)")
            }
            
            Map(coordinateRegion: $region,
                interactionModes: .all,
                showsUserLocation: true,
                annotationItems: annotationSourceItemsViewModel.clusteredAnnotationSourceItems)
            { annotation in
                MapAnnotation(coordinate: CLLocationCoordinate2D(latitude: annotation.coordinates.latitude, longitude: annotation.coordinates.longitude)) {
                    
                    Button(action: {
                        switch annotation.annotationType {
                            
                        case "site":
                            DispatchQueue.main.async {
                                selectedSite = sitesViewModel.sites.first(where: { $0.siteName == annotation.annotationID })
                                return
                            }
                        case "station":
                            DispatchQueue.main.async {
                                selectedSite = Sites(
                                    id: UUID(),
                                    area: "",
                                    siteName: annotation.annotationName,
                                    readingsNote: "",
                                    forecastNote: "",
                                    siteType: "",
                                    readingsAlt: String(annotation.altitude),
                                    readingsSource: annotation.readingsSource,
                                    readingsStation: annotation.annotationID,
                                    pressureZoneReadingTime: "",
                                    siteLat: "\(annotation.coordinates.latitude)",
                                    siteLon: "\(annotation.coordinates.longitude)",
                                    sheetRow: 0
                                )
                                return
                            }
                        case "pilot":
                            DispatchQueue.main.async {
                                selectedPilotTrack = pilotTracksViewModel.pilotTracks.first(where: { $0.pilotName == annotation.annotationID && $0.dateTime == annotation.trackDateTime})
                                return
                            }
                        default:
                            return
                        }
                    }) {
                        switch annotation.annotationType {
                            
                        case "site" :
                            VStack (spacing: 0) {
                                Image(siteAnnotationImage)
                                    .resizable()
                                    .aspectRatio(contentMode: .fit)
                                    .frame(width: defaultAnnotationImageWidth)
                                Text(annotation.annotationName)
                                    .font(.footnote)
                                    .foregroundColor(siteAnnotationTextColor)
                                    .frame(width: annotationTextWidth, height: annotationTextHeight)
                            }
                            
                        case "station" :
                            HStack (spacing: 1) {
                                Text(String(Int(annotation.windSpeed?.rounded() ?? 0)))
                                    .font(.caption)
                                    .foregroundStyle(windSpeedColor(windSpeed: Int(annotation.windSpeed?.rounded() ?? 0), siteType: ""))
                                    .bold()
                                /* Not displaying gusts
                                 Text("g")
                                 .font(.caption2)
                                 Text(String(Int(customAnnotation.windGust?.rounded() ?? 0)))
                                 .font(.caption)
                                 .foregroundStyle(windSpeedColor(windSpeed: Int(customAnnotation.windGust?.rounded() ?? 0), siteType: ""))
                                 .bold()
                                 */
                                Image(systemName: windArrow)
                                    .rotationEffect(.degrees((Double(annotation.windDirection ?? 180)) - 180))
                                    .font(.footnote)
                            }
                            .padding (4)
                            .frame(width: stationAnnotationWidth, height: stationAnnotationHeight)
                            .background(stationAnnotationColor)
                            .cornerRadius(5)
                            
                        case "pilot" :
                            
                            /*
                             // Determine image based on position
                             switch customAnnotation.nodePosition {
                             case "first":
                             annotationImage = pilotLaunchAnnotationUIImage
                             case "last":
                             annotationImage = pilotLatestAnnotationUIImage
                             default:
                             */
                            let pilotName = annotation.annotationName.components(separatedBy: " ").first ?? annotation.annotationName
                            let pilotTrackNodeDateTime = getFormattedTimefromDate(annotation.trackDateTime ?? Date())
                            let pilotTrackNodeAltitude = formatAltitude(String(annotation.altitude))
                            let pilotLabelHeight: CGFloat = getPilotLabelHeightFromMapSpan(span: region.span)
                            let pilotAnnotationImage: String = getPilotAnnotationImage(inEmergency: annotation.inEmergency ?? false, message: annotation.message ?? "")
                            
                            VStack (spacing: 0) {
                                Image(systemName: pilotLaunchAnnotationImage)
                                    .foregroundColor(pilotNodeAnnotationColor)
                                VStack (spacing: 0) {
                                    Text(pilotName)
                                        .font(.footnote)
                                        .foregroundColor(pilotLabelNameTextColor)
                                    if region.span.latitudeDelta < pilotNodeLabelThreeRowSpan {
                                        Text(pilotTrackNodeDateTime)
                                            .font(.caption)
                                            .foregroundColor(pilotLabelDateTextColor)
                                        Text(pilotTrackNodeAltitude)
                                            .font(.caption)
                                            .foregroundColor(pilotLabelAltTextColor)
                                    }
                                }
                                .padding (4)
                                .frame(width: pilotNodeAnnotationTextWidth, height: 60) //pilotLabelHeight)
                                .background(pilotLabelBackgroundColor)
                                .cornerRadius(5)
                            }
                            
                        default:
                            VStack (spacing: 0) {
                                Image(systemName: defaultAnnotationImage)
                                    .foregroundColor(defaultAnnotationColor)
                                Text(annotation.annotationName)
                                    .font(.footnote)
                                    .foregroundColor(defaultAnnotationTextColor)
                                    .frame(width: annotationTextWidth, height: annotationTextHeight)
                            }
                        }
                    }
                }
            }
            .mapStyle(mapSettingsViewModel.selectedMapType.toMapStyle())
            .cornerRadius(10)
            .padding(.vertical, 8)
            
            // Floating Item Bar
            VStack {
                Spacer()
                HStack(alignment: .bottom) {
                    VStack(alignment: .leading) {
                        Button(action: { isLayerSheetPresented.toggle() }) {
                            VStack {
                                Image(systemName: layersImage)
                                    .imageScale(.large)
                                    .foregroundStyle(layersIconColor)
                                Text("Layers")
                                    .font(.caption)
                                    .foregroundColor(layersFontColor)
                            }
                        }
                        .sheet(isPresented: $isLayerSheetPresented) {
                            MapSettingsView(
                                activeLayers: $mapSettingsViewModel.activeLayers,
                                selectedMapType: $mapSettingsViewModel.selectedMapType,
                                pilotTrackDays: $mapSettingsViewModel.pilotTrackDays
                            )
                        }
                    }
                    .padding()
                    .background(layersIconBackgroundColor)
                    .clipShape(RoundedRectangle(cornerRadius: 12))
                    
                    Spacer()
                    
                    VStack(alignment: .trailing) {
                        /*
                         if mapSettingsViewModel.activeLayers.contains(.precipitation) ||
                         mapSettingsViewModel.activeLayers.contains(.cloudCover) {
                         VStack(alignment: .trailing) {
                         HStack(alignment: .center) {
                         Button(action: { isPlaying.toggle() }) {
                         Image(systemName: isPlaying ? "pause.fill" : "play.fill")
                         .imageScale(.large)
                         }
                         .padding(.horizontal, 8)
                         ProgressView(value: animationProgress)
                         .frame(width: 100)
                         Text(currentTime)
                         .font(.headline)
                         .padding(.horizontal, 8)
                         }
                         }
                         .padding()
                         .background(.thinMaterial)
                         .clipShape(RoundedRectangle(cornerRadius: 12))
                         }
                         */
                    }
                }
                .padding(.horizontal, 16)
                .padding(.bottom, 24)
            }
        }
        .onChange(of: MapSettingsState(activeLayers: mapSettingsViewModel.activeLayers,
                                       pilotTrackDays: mapSettingsViewModel.pilotTrackDays,
                                       scenePhase: scenePhase)) {
            // Check all changes together to only execute updateMapAnnotations once
            if scenePhase == .active {
                annotationSourceItemsViewModel.mapSettingsViewModel = mapSettingsViewModel
                annotationSourceItemsViewModel.sitesViewModel = sitesViewModel
                annotationSourceItemsViewModel.stationLatestReadingsViewModel = stationLatestReadingsViewModel
                annotationSourceItemsViewModel.updateAnnotationSourceItems {
                    annotationSourceItemsViewModel.clusterAnnotationSourceItems(regionSpan: region.span)
                    startTimer() // Cancels existing timer and restarts
                    isActive = true
                }
            } else {
                isActive = false
            }
        }
//       .onChange(of: pilotTracksViewModel.pilotTracks) {
//           annotationSourceItemsViewModel.updateAnnotationSourceItems {}
//       }
       .onAppear {
           annotationSourceItemsViewModel.mapSettingsViewModel = mapSettingsViewModel
           annotationSourceItemsViewModel.sitesViewModel = sitesViewModel
           annotationSourceItemsViewModel.stationLatestReadingsViewModel = stationLatestReadingsViewModel
           annotationSourceItemsViewModel.updateAnnotationSourceItems {
               annotationSourceItemsViewModel.clusterAnnotationSourceItems(regionSpan: region.span)
               isActive = true
               startTimer()
               startMonitoringRegion()
           }
       }
       .onDisappear {
           isActive = false
       }
       .sheet(item: $selectedSite) { site in
           SiteDetailView(site: site)
       }
       .sheet(item: $selectedPilotTrack) { pilotTrack in
           PilotTrackNodeView(pilotTrack: pilotTrack)
       }
        // Make sure pilot live track view model is published
       .environmentObject(pilotTracksViewModel)
    }
    
    private func getPilotLabelHeightFromMapSpan(span: MKCoordinateSpan) -> CGFloat {
        if span.latitudeDelta < pilotNodeLabelThreeRowSpan {
            return pilotNodeAnnotationTextThreeRowHeight
        }
        else {
            return pilotNodeAnnotationTextOneRowHeight
        }
    }
    
    private func getPilotAnnotationImage(inEmergency: Bool, message: String) -> String {
        if inEmergency {
            return pilotInEmergencyAnnotationImage
        } else if message != "" {
            return pilotMessageAnnotationImage
        } else {
            return pilotLaunchAnnotationImage
        }
    }
    
    // Timer to reload annotations if page stays active
    private func startTimer() {
        // Cancel any existing timer
        refreshWorkItem?.cancel()
        
        // Create a new work item
        let workItem = DispatchWorkItem {
            if isActive {
                annotationSourceItemsViewModel.mapSettingsViewModel = mapSettingsViewModel
                annotationSourceItemsViewModel.sitesViewModel = sitesViewModel
                annotationSourceItemsViewModel.stationLatestReadingsViewModel = stationLatestReadingsViewModel
                annotationSourceItemsViewModel.updateAnnotationSourceItems {
                    annotationSourceItemsViewModel.clusterAnnotationSourceItems(regionSpan: region.span)
                }
            }
        }
        refreshWorkItem = workItem
        
        // Schedule the new timer
        DispatchQueue.main.asyncAfter(deadline: .now() + pageRefreshInterval, execute: workItem)
    }
    
    private func startMonitoringRegion() {
        Timer.scheduledTimer(withTimeInterval: mapBatchProcessingInterval, repeats: true) { _ in
            let currentSpan = region.span
            if hasRegionSpanChanged(from: lastRegionSpan, to: currentSpan) {
                lastRegionSpan = currentSpan
                annotationSourceItemsViewModel.clusterAnnotationSourceItems(regionSpan: currentSpan)
            }
        }
    }
    
    private func hasRegionSpanChanged(from oldSpan: MKCoordinateSpan, to newSpan: MKCoordinateSpan) -> Bool {
        return abs(oldSpan.latitudeDelta - newSpan.latitudeDelta) > mapScaleChangeTolerance ||
        abs(oldSpan.longitudeDelta - newSpan.longitudeDelta) > mapScaleChangeTolerance
    }
    
}
